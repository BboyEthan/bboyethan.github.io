---
title: "[Interview]2018秋招记录"
layout: post
date: 2018-05-25 17:01
image: /assets/images/markdown.jpg
headerImage: false
tag:
- Interview
- Record
category: blog
author: ethan
description: 面试中遇到的问题及试题整理

---

# 2018秋招记录

__基本数据结构__

*栈*

- 实现一个栈，要求实现出栈，入栈，Min返回最小值的操作的时间复杂度为o(1)
	- 使用两个栈s1和s2，s2做为辅助栈（每次压入s2的都是s1的最小值）。元素x入时将x和s2栈顶元素做比较，如果x小于等于s2.top（），将x分别push到s1和s2，否则x只push到s1 元素出栈时，将s1栈顶元素和s2栈顶元素做比较，如果s1.top（）等于s2.top（），s1和s2都执行pop操作，否则只执行s1.pop（） 

*链表*[表](https://blog.csdn.net/u012428012/article/details/79088036)

- *查找单链表中倒数第K个节点*
	- 这里需要声明两个指针：即两个结点型的变量first和second，首先让first和second都指向第一个结点，然后让second结点往后挪k-1个位置，此时first和second就间隔了k-1个位置，然后整体向后移动这两个节点，直到second节点走到最后一个结点的时候，此时first节点所指向的位置就是倒数第k个节点的位置。时间复杂度为O（n）
- *查找单链表中的中间结点*
	-和上面的第2节一样，也是设置两个指针first和second，只不过这里是，两个指针同时向前走，second指针每次走两步，first指针每次走一步，直到second指针走到最后一个结点时，此时first指针所指的结点就是中间结点。 
- *合并两个有序的单链表，合并之后的链表依然有序【出现频率高】*
	- 挨着比较链表1和链表2。这个类似于归并排序。尤其要注意两个链表都为空、和其中一个为空的情况。只需要O(1)的空间。时间复杂度为O (max(len1,len2))
- *求两个单链表的并集和交集*
	- *差集*
		- 从头往后面进行遍历，如果两个链表的元素相同，就删除
	- *并集*
		- 先用归并排序，然后线性遍历两个链表，如A<B,则A后移，如果A>B,则B后移，否则同时移动。复杂度为O（mlogm+nlogn）。
- *链表反转*
	-  

*队列*

q = Queue.Queue()

*二叉树* [树](https://blog.csdn.net/u012428012/article/details/79089915)

- *求二叉树的深度*
 - int treeDepth(BinaryTreeNode* root){
    if(root==NULL){
        return 0;
    }
    int nLeft=treeDepth(root->m_pLeft);
    int nRight=treeDepth(root->m_pRight);
    return nLeft>nRight?nLeft+1:nRight+1;
}

- *求二叉树的宽度*
	- 这里需要用到二叉树的层次遍历，即广度优先遍历。在层次遍历的过程中，通过读取队列中保留的上一层的节点数来记录每层的节点数，以获取所有层中最大的节点数 
	- //记录上一层的宽度  
 	-  //记录当前层的宽度
 	-    //将根节点入队列  
    int nWidth = 1;//二叉树的宽度  
    nLastLevelWidth = 1;      
    BinaryTreeNode *pCur = NULL;  

    while (!myQueue.empty())//队列不空  
    {  
        while (nLastLevelWidth!= 0){  
            pCur = myQueue.front();//取出队列头元素  
            myQueue.pop();//将队列头元素出对  

            if (pCur->m_pLeft != NULL)  
                myQueue.push(pCur->m_pLeft);   

            if (pCur->m_pRight != NULL)  
                myQueue.push(pCur->m_pRight); 
            nLastLevelWidth--;  
        }  

        nCurLevelWidth = myQueue.size();  
        nWidth = nCurLevelWidth > nWidth ? nCurLevelWidth : nWidth;  
        nLastLevelWidth = nCurLevelWidth;  
    }  
    return nWidth;  
 
- *层次遍历*
 -     def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """

        if root == None:
            return []
        res = []
        queue = [root]

        while queue:
            level = []
            for i in range(len(queue)):          
                node = queue.pop(0)
                level.append(node.val)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                # print(queue)
            res.append(level)
            
        return res
        
- *三种遍历*
	- 递归的三种遍历
	- 非递归后续
	- 
public static void postorderTraversal(TreeNode root) {
    if(root == null) {
        return;
    }
    Stack<TreeNode> stack1 = new Stack<>(); // 保存树节点
    Stack<TreeNode> stack2 = new Stack<>(); // 保存后序遍历的结果
    stack1.add(root);
    while (!stack1.isEmpty()) {
        TreeNode temp = stack1.pop();
        stack2.push(temp); // 将弹出的元素加到stack2中
        if (temp.left != null) { // 左子节点先入栈
            stack1.push(temp.left);
        }
        if (temp.right != null) { // 右子节点后入栈
            stack1.push(temp.right);
        }
    }
    while (!stack2.isEmpty()) {
        System.out.print(stack2.pop().val + "->");
    }
}
- *建立BST*
	-
void InsertNode(BSTNode *&root, int data)  
{  
	if(root == NULL)  
	{  
		root = new BSTNode;
		root->left = NULL;  
		root->right = NULL;  
		root->val = data;  
	}  
	else if(root->val < data)
		InsertNode(root->right,data);  
	else if(root->val > data)
		InsertNode(root->left,data);  
	else
		;//duplicate, do nothing
}
 
void BuildBST(BSTNode *&root, int a[], int n)
{
	for (int i = 0; i < n; i++)
	{
		InsertNode(root,a[i]);
	}
 
 *哈希表查找*
 - .根据待查找记录的关键字和建表时的哈希函数计算散列地址； 
2.若该地址单元为空，则查找失败；若不为空，则将该单元中的关键字与待查记录的关键字进行比较： 
　　如果相等，则查找成功； 
　　如果不等，则按建表时设定的处理冲突的方法找下一个地址。 
3.重复上述步骤2，直至某个单元为空，则查找失败或者与待查记录的关键字进行比较，相等则查找成功。	